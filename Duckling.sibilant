
(var state  (.then (.login client token) (aprint "login success") (athrow Error "login failed")))
(var brain (Model))
(require! (lit Tree-map) "ai/lib/tree")
(var user-models (Model))

(def-curried say (t noun)
  (.writes noun [t]))


(macro def-actor (name args ...body)
       )
(def-interface Short-term-memory ())
(def-interface Messages ())
(def-interface Next-response ())

(def-interface Duckling ()

  (extend Event-emitter.prototype)

  (init (.call Event-emitter this))
  (user-models user-models)

  (client client)
  (token token)

  (brain brain)


  (sett channel keys (task (assign this.*channel keys)))
  (gett channel (task (print "getting channel" this.*channel)(.find Channel-system this.*channel)))


  (state state)


  (def-generic reads (msg)
    "takes data and introduces it to ducklings brain"

    (task


     (unless (= msg.author.username client.user.username)
       (print "msg author" msg.author.username)
       (assign this.*channel [msg.guild.name msg.channel.name])
       (assign this.*last-user-name msg.author.username)
       (print "channel" this.*channel)
       (print"username" this.*last-user-name)

       (var t msg.content)
       (var o (.split t (regex "\\s")))
       (print "reads" o)


       (.emit this 'reads o)

       ;; (if (.includes t "duckling")
       ;;         (var r (.random-sequence this.brain 20))

       ;;         (do (print "[duckling was mentioned]" r)
       ;;         (.writes this )))
       )))

  (def-generic remembers (word-list)
    (task

     (.add this.brain [this.*last-user-name
                       (dots this.*channel)])

     (.train (.given this.brain
                     [this.*last-user-name
                      (dots this.*channel)])
             5 word-list)


     (.add this.brain
           [(dots this.*channel)
            this.*last-user-name])

     (.train (.given this.brain
                     [(dots this.*channel)
                      this.*last-user-name])
             5 word-list)

     (.train this.brain 5 word-list)

     (.degrade this.brain (get (.random this.brain) 'seq))

     (.emit this 'remembers [this.brain word-list] )))

  (response [])
  (context [null null null null])

  (def thinks ([model words] )
    (print "attempting to think")

    (task
     ;;(unless (.some words include-ducklings-name))

     (var self this)
     (var r (.random (let ((channel (.given model [(dots self.*channel) ]))
                           (user (.given model [self.*last-user-name ])))

                       (print "choosing between  models"
                              (lit channel user))

                       (print "likelyhoods"
                              self.context
                              (.likelyhood channel [self.*last-user-name
                                                    (dots self.context)])

                              (.likelyhood user [self.*channel
                                                 (dots self.context)])

                              (.likelyhood model self.context)
                              )
                       (var l [(.likelyhood channel [self.*last-user-name])
                               (.likelyhood user self.*channel)])

                       (if (and (not (isNaN (first l)))
                                (not (isNaN (second l))))
                           (if (> (.likelyhood channel [self.*last-user-name])
                                  (.likelyhood user self.*channel))

                               (.given channel [self.*last-user-name (dots self.context)])

                               (.given user [ (dots self.*channel) (dots self.context)]))
                           (.given model self.context)))))
     ;;(print "thought")

     (print "chose" r )
     (var token (get r 'token))
     (assign this.context [(dots (rest this.context)) token])

     (print "thinking" this.context )

     ;;(print "likelyhood" r.likelyhood)
     (.catch
      (.resolve Promise
                (if (= null token)
                    (do (print "done thinking")
                        (.emit this 'thinks this.response)
                      (assign this.response []))

                    (do

                     (.push this.response token)
                     (if (or (< r.likelyhood 0.1)
                             (.some ["Duckling" "duckling" "you" "your" "you're" ]
                                    (=> (name) (= name token))))

                         (do (print "thinking hard..." )
                             (.emit this 'remembers [model words] ))))))
      (aprint "lost a thought...."))))

  (def-generic writes ( (s []) channel)

    (var t (+ (.join s " ") "."))
    (task
     (.catch (then channel c

            (unless (= t ".")

              c.startTyping()

              (c.send t)

              (print "[DUCKLING] "  t)
              (c.stopTyping true)
              (.emit this 'writes t)
              (pipe (.save Storage "./models/duckling-core" this.brain)
                    (.then (aprint "saved duckling"))
                    (.catch (aprint "failed to save duckling")))))
             (aprint "failed to write")))))




;; (print (.find Channel-system ["Error log" "bot-tests"]))



;; (print (.find client.guilds (=> (v) (= v.name "Error log"))))

;; (print client.guilds)
;; (print client)






